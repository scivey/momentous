// Generated by CoffeeScript 1.6.3
(function() {
  var assert, catMoments, cloneMomentList, flatSplat, inDir, inLib, inSpec, intRange, makeMomentBetween, makeNMomentsBetween, moment, path, _, _mr,
    __slice = [].slice;

  _ = require("underscore");

  moment = require("moment");

  path = require("path");

  assert = require("better-assert");

  inDir = function(dir) {
    if (dir == null) {
      dir = __dirname;
    }
    return function(fName) {
      return path.join(dir, fName);
    };
  };

  inSpec = inDir();

  inLib = inDir("../lib");

  _mr = require(inLib("ranges.js"));

  intRange = function(start, end) {
    var num, offset, range;
    range = (end - start) + 1;
    offset = Math.random() * range;
    offset = Math.floor(offset);
    num = start + offset;
    return num;
  };

  makeMomentBetween = function(first, second) {
    var diffAmt, working, _diff;
    working = second.clone();
    _diff = working.diff(first);
    _diff = Math.abs(_diff);
    diffAmt = Math.random() * _diff;
    if (diffAmt < 0.05) {
      diffAmt += 0.05;
    }
    if (diffAmt > 0.95) {
      diffAmt -= 0.05;
    }
    working.subtract(diffAmt);
    return working;
  };

  makeNMomentsBetween = function(n, first, second) {
    var _count, _moments;
    _moments = [];
    _count = n;
    while (n--) {
      _moments.push(makeMomentBetween(first, second));
    }
    return _moments;
  };

  flatSplat = function(list) {
    if (_.size(list) === 1 && _.isArray(list[0])) {
      return list[0];
    }
    return list;
  };

  cloneMomentList = function(momentList) {
    var outs;
    if (moment.isMoment(momentList)) {
      return momentList.clone();
    }
    momentList = flatSplat(momentList);
    outs = _.map(momentList, function(oneMoment) {
      return oneMoment.clone();
    });
    return outs;
  };

  catMoments = function() {
    var momentLists, _momentLists;
    momentLists = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _momentLists = _.flatten(flatSplat(momentLists));
    return _momentLists;
  };

  describe("momentous", function() {
    var inTenDays, now, tomorrow, yesterday;
    now = moment();
    yesterday = {};
    tomorrow = {};
    inTenDays = {};
    beforeEach(function() {
      now = moment();
      yesterday = now.clone().subtract("days", 1);
      tomorrow = now.clone().add("days", 1);
      return inTenDays = now.clone().add("days", 10);
    });
    describe("range", function() {
      it("accepts a start moment, end moment, and step size", function() {
        var range;
        range = _mr.range(now, inTenDays, {
          days: 1
        });
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.range(now, inTenDays, {
          days: 1
        });
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("includes its start point", function() {
        var range, _now, _same;
        range = _mr.range(now, inTenDays, {
          days: 1
        });
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert(moment.isMoment(_same));
      });
      it("does not include its end point", function() {
        var range, _inTen, _same;
        range = _mr.range(now, inTenDays, {
          days: 1
        });
        _inTen = inTenDays.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _inTen;
        });
        return assert((_same != null) === false);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.range(now, tomorrow, {
          hours: 2
        });
        last = now.clone();
        _manRange = [];
        while (last.isBefore(tomorrow)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 2
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.range(now, tomorrow, {
          hours: 2
        });
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "m");
          _diff = last.diff(range[i], "m");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("rangeExclusive", function() {
      it("accepts a start moment, end moment, and step size", function() {
        var range;
        range = _mr.rangeExclusive(now, inTenDays, {
          days: 1
        });
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.rangeExclusive(now, inTenDays, {
          days: 1
        });
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its start point", function() {
        var range, _now, _same;
        range = _mr.rangeExclusive(now, inTenDays, {
          days: 1
        });
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("does not include its end point", function() {
        var range, _inTen, _same;
        range = _mr.rangeExclusive(now, inTenDays, {
          days: 1
        });
        _inTen = inTenDays.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _inTen;
        });
        return assert((_same != null) === false);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.rangeExclusive(now, tomorrow, {
          hours: 2
        });
        last = now.clone().add({
          hours: 2
        });
        _manRange = [];
        while (last.isBefore(tomorrow)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 2
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.rangeExclusive(now, tomorrow, {
          hours: 2
        });
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "m");
          _diff = last.diff(range[i], "m");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("rangeBy", function() {
      it("accepts a step size, start moment, and end moment", function() {
        var range;
        range = _mr.rangeBy({
          days: 1
        }, now, inTenDays);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.rangeBy({
          days: 1
        }, now, inTenDays);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("includes its start point", function() {
        var range, _now, _same;
        range = _mr.rangeBy({
          days: 1
        }, now, inTenDays);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert(moment.isMoment(_same));
      });
      it("does not include its end point", function() {
        var range, _inTen, _same;
        range = _mr.rangeBy({
          days: 1
        }, now, inTenDays);
        _inTen = inTenDays.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _inTen;
        });
        return assert((_same != null) === false);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.rangeBy({
          hours: 2
        }, now, tomorrow);
        last = now.clone();
        _manRange = [];
        while (last.isBefore(tomorrow)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 2
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.rangeBy({
          hours: 2
        }, now, tomorrow);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "m");
          _diff = last.diff(range[i], "m");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("rangeByExclusive", function() {
      it("accepts a step size, start moment, and end moment", function() {
        var range;
        range = _mr.rangeByExclusive({
          days: 1
        }, now, inTenDays);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.rangeByExclusive({
          days: 1
        }, now, inTenDays);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its start point", function() {
        var range, _now, _same;
        range = _mr.rangeByExclusive({
          days: 1
        }, now, inTenDays);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("does not include its end point", function() {
        var range, _inTen, _same;
        range = _mr.rangeByExclusive({
          days: 1
        }, now, inTenDays);
        _inTen = inTenDays.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _inTen;
        });
        return assert((_same != null) === false);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.rangeByExclusive({
          hours: 2
        }, now, tomorrow);
        last = now.clone().add({
          hours: 2
        });
        _manRange = [];
        while (last.isBefore(tomorrow)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 2
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.rangeByExclusive({
          hours: 2
        }, now, tomorrow);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "m");
          _diff = last.diff(range[i], "m");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("nStepsBefore", function() {
      it("accepts a number of steps, a step size, and an ending moment", function() {
        var range;
        range = _mr.nStepsBefore(10, {
          hours: 1
        }, now);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.nStepsBefore(15, {
          days: 1
        }, now);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its end point", function() {
        var range, _now, _same;
        range = _mr.nStepsBefore(15, {
          days: 1
        }, now);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (end - (nSteps * stepSize))", function() {
        var range, _15daysago, _same;
        range = _mr.nStepsBefore(15, {
          days: 1
        }, now);
        _15daysago = now.clone().subtract({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _15daysago;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.nStepsBefore(15, {
          days: 1
        }, now);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.nStepsBefore(20, {
          hours: 1
        }, now);
        last = now.clone().subtract({
          hours: 20
        });
        _manRange = [];
        while (last.isBefore(now)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.nStepsBefore(12, {
          hours: 2
        }, now);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("nStepsAfter", function() {
      it("accepts a number of steps, a step size, and a starting moment", function() {
        var range;
        range = _mr.nStepsAfter(10, {
          hours: 1
        }, now);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.nStepsAfter(15, {
          days: 1
        }, now);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its starting point", function() {
        var range, _now, _same;
        range = _mr.nStepsAfter(15, {
          days: 1
        }, now);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (start + (nSteps * stepSize))", function() {
        var in15days, range, _same;
        range = _mr.nStepsAfter(15, {
          days: 1
        }, now);
        in15days = now.clone().add({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === in15days;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.nStepsAfter(15, {
          days: 1
        }, now);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange, _steps;
        range = _mr.nStepsAfter(20, {
          hours: 1
        }, now);
        last = now.clone().add({
          hours: 1
        });
        _steps = 20;
        _manRange = [];
        while (_steps--) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.nStepsAfter(12, {
          hours: 2
        }, now);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("stepsBeforeBy", function() {
      it("accepts a step size, a number of steps, and an ending moment", function() {
        var range;
        range = _mr.stepsBeforeBy({
          hours: 1
        }, 10, now);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.stepsBeforeBy({
          days: 1
        }, 15, now);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its end point", function() {
        var range, _now, _same;
        range = _mr.stepsBeforeBy({
          days: 1
        }, 15, now);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (end - (nSteps * stepSize))", function() {
        var range, _15daysago, _same;
        range = _mr.stepsBeforeBy({
          days: 1
        }, 15, now);
        _15daysago = now.clone().subtract({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _15daysago;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.stepsBeforeBy({
          days: 1
        }, 15, now);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.stepsBeforeBy({
          hours: 1
        }, 20, now);
        last = now.clone().subtract({
          hours: 20
        });
        _manRange = [];
        while (last.isBefore(now)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.stepsBeforeBy({
          hours: 2
        }, 12, now);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("stepsAfterBy", function() {
      it("accepts a step size, a number of steps, and a starting moment", function() {
        var range;
        range = _mr.stepsAfterBy({
          hours: 1
        }, 10, now);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.stepsAfterBy({
          days: 1
        }, 15, now);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its starting point", function() {
        var range, _now, _same;
        range = _mr.stepsAfterBy({
          days: 1
        }, 15, now);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (start + (nSteps * stepSize))", function() {
        var in15days, range, _same;
        range = _mr.stepsAfterBy({
          days: 1
        }, 15, now);
        in15days = now.clone().add({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === in15days;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.stepsAfterBy({
          days: 1
        }, 15, now);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange, _steps;
        range = _mr.stepsAfterBy({
          hours: 1
        }, 20, now);
        last = now.clone().add({
          hours: 1
        });
        _steps = 20;
        _manRange = [];
        while (_steps--) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.stepsAfterBy({
          hours: 2
        }, 12, now);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    describe("stepsBeforeMoment", function() {
      it("accepts an ending moment, a step size, and a number of steps", function() {
        var range;
        range = _mr.stepsBeforeMoment(now, {
          hours: 1
        }, 10);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.stepsBeforeMoment(now, {
          days: 1
        }, 15);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its end point", function() {
        var range, _now, _same;
        range = _mr.stepsBeforeMoment(now, {
          days: 1
        }, 15);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (end - (nSteps * stepSize))", function() {
        var range, _15daysago, _same;
        range = _mr.stepsBeforeMoment(now, {
          days: 1
        }, 15);
        _15daysago = now.clone().subtract({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _15daysago;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.stepsBeforeMoment(now, {
          days: 1
        }, 15);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange;
        range = _mr.stepsBeforeMoment(now, {
          hours: 1
        }, 20);
        last = now.clone().subtract({
          hours: 20
        });
        _manRange = [];
        while (last.isBefore(now)) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.stepsBeforeMoment(now, {
          hours: 2
        }, 12);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
    return describe("stepsAfterMoment", function() {
      it("accepts a start moment, a step size, and a number of steps.", function() {
        var range;
        range = _mr.stepsAfterMoment(now, {
          hours: 1
        }, 10);
        return _.each(range, function(aMoment) {
          return assert(moment.isMoment(aMoment));
        });
      });
      it("generates a linear sequence of moments", function() {
        var i, range, _current, _i, _ref, _results;
        range = _mr.stepsAfterMoment(now, {
          days: 1
        }, 15);
        _current = range[0];
        _results = [];
        for (i = _i = i, _ref = range.length - 1; i <= _ref ? _i <= _ref : _i >= _ref; i = i <= _ref ? ++_i : --_i) {
          _results.push(assert(_current.isBefore(range[i])));
        }
        return _results;
      });
      it("does not include its starting point", function() {
        var range, _now, _same;
        range = _mr.stepsAfterMoment(now, {
          days: 1
        }, 15);
        _now = now.valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === _now;
        });
        return assert((_same != null) === false);
      });
      it("includes the moment at (start + (nSteps * stepSize))", function() {
        var in15days, range, _same;
        range = _mr.stepsAfterMoment(now, {
          days: 1
        }, 15);
        in15days = now.clone().add({
          days: 15
        }).valueOf();
        _same = _.find(range, function(aMoment) {
          return aMoment.valueOf() === in15days;
        });
        return assert(moment.isMoment(_same));
      });
      it("generates the correct number of steps", function() {
        var range;
        range = _mr.stepsAfterMoment(now, {
          days: 1
        }, 15);
        return assert(_.size(range) === 15);
      });
      it("produces the same result as manual iteration", function() {
        var last, range, zipped, _manRange, _steps;
        range = _mr.stepsAfterMoment(now, {
          hours: 1
        }, 20);
        last = now.clone().add({
          hours: 1
        });
        _steps = 20;
        _manRange = [];
        while (_steps--) {
          _manRange.push(last);
          last = last.clone().add({
            hours: 1
          });
        }
        assert(_.size(_manRange) === _.size(range));
        zipped = _.zip(range, _manRange);
        return _.each(zipped, function(aPair) {
          return assert(aPair[0].valueOf() === aPair[1].valueOf());
        });
      });
      return it("increases by the given step size", function() {
        var i, last, range, _diff, _i, _manDiff, _ref, _results;
        range = _mr.stepsAfterMoment(now, {
          hours: 2
        }, 12);
        last = range[0];
        _results = [];
        for (i = _i = 1, _ref = range.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _manDiff = last.diff(last.clone().add({
            hours: 2
          }), "s");
          _diff = last.diff(range[i], "s");
          assert(_manDiff === _diff);
          _results.push(last = range[i]);
        }
        return _results;
      });
    });
  });

}).call(this);
