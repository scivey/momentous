// Generated by CoffeeScript 1.6.3
(function() {
  var assert, catMoments, cloneMomentList, flatSplat, inDir, inLib, inSpec, intRange, makeMomentBetween, makeNMomentsBetween, meq, moment, path, sel, _, _m,
    __slice = [].slice;

  _ = require("underscore");

  moment = require("moment");

  path = require("path");

  assert = require("better-assert");

  inDir = function(dir) {
    if (dir == null) {
      dir = __dirname;
    }
    return function(fName) {
      return path.join(dir, fName);
    };
  };

  inSpec = inDir();

  inLib = inDir("../lib");

  sel = require(inLib("selectors.js"));

  intRange = function(start, end) {
    var num, offset, range;
    range = (end - start) + 1;
    offset = Math.random() * range;
    offset = Math.floor(offset);
    num = start + offset;
    return num;
  };

  makeMomentBetween = function(first, second) {
    var diffAmt, working, _diff;
    working = second.clone();
    _diff = working.diff(first);
    _diff = Math.abs(_diff);
    diffAmt = Math.random() * _diff;
    if (diffAmt < 0.05) {
      diffAmt += 0.05;
    }
    if (diffAmt > 0.95) {
      diffAmt -= 0.05;
    }
    working.subtract(diffAmt);
    return working;
  };

  makeNMomentsBetween = function(n, first, second) {
    var _count, _moments;
    _moments = [];
    _count = n;
    while (n--) {
      _moments.push(makeMomentBetween(first, second));
    }
    return _moments;
  };

  flatSplat = function(list) {
    if (_.size(list) === 1 && _.isArray(list[0])) {
      return list[0];
    }
    return list;
  };

  cloneMomentList = function(momentList) {
    var outs;
    if (moment.isMoment(momentList)) {
      return momentList.clone();
    }
    momentList = flatSplat(momentList);
    outs = _.map(momentList, function(oneMoment) {
      return oneMoment.clone();
    });
    return outs;
  };

  catMoments = function() {
    var momentLists, _momentLists;
    momentLists = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _momentLists = _.flatten(flatSplat(momentLists));
    return _momentLists;
  };

  _m = require(inLib("addersubber.js"));

  meq = function(moment1, moment2) {
    if (moment1.format() === moment2.format()) {
      return true;
    }
    return false;
  };

  describe("momentous", function() {
    var now, tomorrow, yesterday;
    now = moment();
    yesterday = {};
    tomorrow = {};
    beforeEach(function() {
      now = moment();
      yesterday = now.clone().subtract("days", 1);
      return tomorrow = now.clone().add("days", 1);
    });
    describe("sub", function() {
      it("accepts a moment instance and object literal", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = _m.sub(now, {
          years: 2,
          days: 5
        });
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = _m.sub(now, {
          years: 2,
          days: 5
        });
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subFromNow;
        subFromNow = _m.sub(now);
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = subFromNow({
          years: 2,
          days: 5
        });
        return assert(meq(compare, against));
      });
    });
    describe("subBy", function() {
      it("accepts an object literal and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = _m.subBy({
          years: 2,
          days: 5
        }, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = _m.subBy({
          years: 2,
          days: 5
        }, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub2y5d;
        sub2y5d = _m.subBy({
          years: 2,
          days: 5
        });
        compare = now.clone().subtract("years", 2).subtract("days", 5);
        against = sub2y5d(now);
        return assert(meq(compare, against));
      });
    });
    describe("sub.years", function() {
      it("accepts a moment instance and a number of years to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2);
        against = _m.sub.years(now, 2);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2);
        against = _m.sub.years(now, 2);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subYearsFromNow;
        subYearsFromNow = _m.sub.years(now);
        compare = now.clone().subtract("years", 2);
        against = subYearsFromNow(2);
        return assert(meq(compare, against));
      });
    });
    describe("sub.months", function() {
      it("accepts a moment instance and a number of months to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("months", 2);
        against = _m.sub.months(now, 2);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("months", 2);
        against = _m.sub.months(now, 2);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subMonthsFromNow;
        subMonthsFromNow = _m.sub.months(now);
        compare = now.clone().subtract("months", 2);
        against = subMonthsFromNow(2);
        return assert(meq(compare, against));
      });
    });
    describe("sub.days", function() {
      it("accepts a moment instance and a number of days to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("days", 10);
        against = _m.sub.days(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("days", 10);
        against = _m.sub.days(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subDaysFromNow;
        subDaysFromNow = _m.sub.days(now);
        compare = now.clone().subtract("days", 10);
        against = subDaysFromNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("sub.hours", function() {
      it("accepts a moment instance and a number of hours to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("hours", 10);
        against = _m.sub.hours(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("hours", 10);
        against = _m.sub.hours(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subHoursFromNow;
        subHoursFromNow = _m.sub.hours(now);
        compare = now.clone().subtract("hours", 10);
        against = subHoursFromNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("sub.minutes", function() {
      it("accepts a moment instance and a number of minutes to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("minutes", 10);
        against = _m.sub.minutes(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("minutes", 10);
        against = _m.sub.minutes(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subMinsFromNow;
        subMinsFromNow = _m.sub.minutes(now);
        compare = now.clone().subtract("minutes", 10);
        against = subMinsFromNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("sub.seconds", function() {
      it("accepts a moment instance and a number of seconds to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("seconds", 10);
        against = _m.sub.seconds(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("seconds", 10);
        against = _m.sub.seconds(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subSecFromNow;
        subSecFromNow = _m.sub.seconds(now);
        compare = now.clone().subtract("seconds", 10);
        against = subSecFromNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("sub.msec", function() {
      it("accepts a moment instance and a number of seconds to subtract", function() {
        var against, compare;
        compare = now.clone().subtract("milliseconds", 2500);
        against = _m.sub.msec(now, 2500);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("milliseconds", 2500);
        against = _m.sub.msec(now, 2500);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, subMsecFromNow;
        subMsecFromNow = _m.sub.msec(now);
        compare = now.clone().subtract("milliseconds", 2500);
        against = subMsecFromNow(2500);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.years", function() {
      it("accepts a number of years to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2);
        against = _m.subBy.years(2, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("years", 2);
        against = _m.subBy.years(2, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub2y;
        sub2y = _m.subBy.years(2);
        compare = now.clone().subtract("years", 2);
        against = sub2y(now);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.months", function() {
      it("accepts a number of months and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("months", 2);
        against = _m.subBy.months(2, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("months", 2);
        against = _m.subBy.months(2, now);
        assert(meq(compare, against));
        return assert(meq(compare, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub2m;
        sub2m = _m.subBy.months(2);
        compare = now.clone().subtract("months", 2);
        against = sub2m(now);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.days", function() {
      it("accepts a number of days to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("days", 10);
        against = _m.subBy.days(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("days", 10);
        against = _m.subBy.days(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub10d;
        sub10d = _m.subBy.days(10);
        compare = now.clone().subtract("days", 10);
        against = sub10d(now);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.hours", function() {
      it("accepts a number of hours to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("hours", 10);
        against = _m.subBy.hours(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("hours", 10);
        against = _m.subBy.hours(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub10h;
        sub10h = _m.subBy.hours(10);
        compare = now.clone().subtract("hours", 10);
        against = sub10h(now);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.minutes", function() {
      it("accepts a number of minutes to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("minutes", 10);
        against = _m.subBy.minutes(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("minutes", 10);
        against = _m.subBy.minutes(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub10mins;
        sub10mins = _m.subBy.minutes(10);
        compare = now.clone().subtract("minutes", 10);
        against = sub10mins(now);
        return assert(meq(compare, against));
      });
    });
    describe("subBy.seconds", function() {
      it("accepts a number of seconds to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("seconds", 10);
        against = _m.subBy.seconds(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("seconds", 10);
        against = _m.subBy.seconds(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub10sec;
        sub10sec = _m.subBy.seconds(10);
        compare = now.clone().subtract("seconds", 10);
        against = sub10sec(now);
        return assert(meq(compare, against));
      });
    });
    return describe("subBy.msec", function() {
      it("accepts a number of milliseconds to subtract and a moment instance", function() {
        var against, compare;
        compare = now.clone().subtract("milliseconds", 3500);
        against = _m.subBy.msec(3500, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().subtract("milliseconds", 3500);
        against = _m.subBy.msec(3500, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var against, compare, sub3500;
        sub3500 = _m.subBy.msec(3500);
        compare = now.clone().subtract("milliseconds", 3500);
        against = sub3500(now);
        return assert(meq(compare, against));
      });
    });
  });

}).call(this);
