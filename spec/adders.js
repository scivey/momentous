// Generated by CoffeeScript 1.6.3
(function() {
  var assert, catMoments, cloneMomentList, flatSplat, inDir, inLib, inSpec, intRange, makeMomentBetween, makeNMomentsBetween, meq, moment, path, sel, _, _m,
    __slice = [].slice;

  _ = require("underscore");

  moment = require("moment");

  path = require("path");

  assert = require("better-assert");

  inDir = function(dir) {
    if (dir == null) {
      dir = __dirname;
    }
    return function(fName) {
      return path.join(dir, fName);
    };
  };

  inSpec = inDir();

  inLib = inDir("../lib");

  sel = require(inLib("selectors.js"));

  intRange = function(start, end) {
    var num, offset, range;
    range = (end - start) + 1;
    offset = Math.random() * range;
    offset = Math.floor(offset);
    num = start + offset;
    return num;
  };

  makeMomentBetween = function(first, second) {
    var diffAmt, working, _diff;
    working = second.clone();
    _diff = working.diff(first);
    _diff = Math.abs(_diff);
    diffAmt = Math.random() * _diff;
    if (diffAmt < 0.05) {
      diffAmt += 0.05;
    }
    if (diffAmt > 0.95) {
      diffAmt -= 0.05;
    }
    working.subtract(diffAmt);
    return working;
  };

  makeNMomentsBetween = function(n, first, second) {
    var _count, _moments;
    _moments = [];
    _count = n;
    while (n--) {
      _moments.push(makeMomentBetween(first, second));
    }
    return _moments;
  };

  flatSplat = function(list) {
    if (_.size(list) === 1 && _.isArray(list[0])) {
      return list[0];
    }
    return list;
  };

  cloneMomentList = function(momentList) {
    var outs;
    if (moment.isMoment(momentList)) {
      return momentList.clone();
    }
    momentList = flatSplat(momentList);
    outs = _.map(momentList, function(oneMoment) {
      return oneMoment.clone();
    });
    return outs;
  };

  catMoments = function() {
    var momentLists, _momentLists;
    momentLists = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _momentLists = _.flatten(flatSplat(momentLists));
    return _momentLists;
  };

  _m = require(inLib("addersubber.js"));

  meq = function(moment1, moment2) {
    if (moment1.format() === moment2.format()) {
      return true;
    }
    return false;
  };

  describe("momentous", function() {
    var now, tomorrow, yesterday;
    now = moment();
    yesterday = {};
    tomorrow = {};
    beforeEach(function() {
      now = moment();
      yesterday = now.clone().subtract("days", 1);
      return tomorrow = now.clone().add("days", 1);
    });
    describe("add", function() {
      it("accepts a moment instance and object literal", function() {
        var against, compare;
        compare = now.clone().add("years", 2).add("days", 5);
        against = _m.add(now, {
          years: 2,
          days: 5
        });
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("years", 2).add("days", 5);
        against = _m.add(now, {
          years: 2,
          days: 5
        });
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addToNow, against, compare;
        addToNow = _m.add(now);
        compare = now.clone().add("years", 2).add("days", 5);
        against = addToNow({
          years: 2,
          days: 5
        });
        return assert(meq(compare, against));
      });
    });
    describe("addBy", function() {
      it("accepts an object literal and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("years", 2).add("days", 5);
        against = _m.addBy({
          years: 2,
          days: 5
        }, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("years", 2).add("days", 5);
        against = _m.addBy({
          years: 2,
          days: 5
        }, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add2years5days, against, compare;
        add2years5days = _m.addBy({
          years: 2,
          days: 5
        });
        compare = now.clone().add("years", 2).add("days", 5);
        against = add2years5days(now);
        return assert(meq(compare, against));
      });
    });
    describe("add.years", function() {
      it("accepts a moment instance and a number of years to add", function() {
        var against, compare;
        compare = now.clone().add("years", 2);
        against = _m.add.years(now, 2);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("years", 2);
        against = _m.add.years(now, 2);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addYearsToNow, against, compare;
        addYearsToNow = _m.add.years(now);
        compare = now.clone().add("years", 2);
        against = addYearsToNow(2);
        return assert(meq(compare, against));
      });
    });
    describe("add.months", function() {
      it("accepts a moment instance and a number of months to add", function() {
        var against, compare;
        compare = now.clone().add("months", 2);
        against = _m.add.months(now, 2);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("months", 2);
        against = _m.add.months(now, 2);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addMonthsToNow, against, compare;
        addMonthsToNow = _m.add.months(now);
        compare = now.clone().add("months", 2);
        against = addMonthsToNow(2);
        return assert(meq(compare, against));
      });
    });
    describe("add.days", function() {
      it("accepts a moment instance and a number of days to add", function() {
        var against, compare;
        compare = now.clone().add("days", 10);
        against = _m.add.days(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("days", 10);
        against = _m.add.days(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addDaysToNow, against, compare;
        addDaysToNow = _m.add.days(now);
        compare = now.clone().add("days", 10);
        against = addDaysToNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("add.hours", function() {
      it("accepts a moment instance and a number of hours to add", function() {
        var against, compare;
        compare = now.clone().add("hours", 10);
        against = _m.add.hours(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("hours", 10);
        against = _m.add.hours(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addHoursToNow, against, compare;
        addHoursToNow = _m.add.hours(now);
        compare = now.clone().add("hours", 10);
        against = addHoursToNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("add.minutes", function() {
      it("accepts a moment instance and a number of minutes to add", function() {
        var against, compare;
        compare = now.clone().add("minutes", 10);
        against = _m.add.minutes(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("minutes", 10);
        against = _m.add.minutes(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addMinutesToNow, against, compare;
        addMinutesToNow = _m.add.minutes(now);
        compare = now.clone().add("minutes", 10);
        against = addMinutesToNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("add.seconds", function() {
      it("accepts a moment instance and a number of seconds to add", function() {
        var against, compare;
        compare = now.clone().add("seconds", 10);
        against = _m.add.seconds(now, 10);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("seconds", 10);
        against = _m.add.seconds(now, 10);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addSecondsToNow, against, compare;
        addSecondsToNow = _m.add.seconds(now);
        compare = now.clone().add("seconds", 10);
        against = addSecondsToNow(10);
        return assert(meq(compare, against));
      });
    });
    describe("add.msec", function() {
      it("accepts a moment instance and a number of seconds to add", function() {
        var against, compare;
        compare = now.clone().add("milliseconds", 2500);
        against = _m.add.msec(now, 2500);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("milliseconds", 2500);
        against = _m.add.msec(now, 2500);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var addMSecToNow, against, compare;
        addMSecToNow = _m.add.msec(now);
        compare = now.clone().add("milliseconds", 2500);
        against = addMSecToNow(2500);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.years", function() {
      it("accepts a number of years to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("years", 2);
        against = _m.addBy.years(2, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("years", 2);
        against = _m.addBy.years(2, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add2years, against, compare;
        add2years = _m.addBy.years(2);
        compare = now.clone().add("years", 2);
        against = add2years(now);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.months", function() {
      it("accepts a number of months and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("months", 2);
        against = _m.addBy.months(2, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("months", 2);
        against = _m.addBy.months(2, now);
        assert(meq(compare, against));
        return assert(meq(compare, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add2months, against, compare;
        add2months = _m.addBy.months(2);
        compare = now.clone().add("months", 2);
        against = add2months(now);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.days", function() {
      it("accepts a number of days to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("days", 10);
        against = _m.addBy.days(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("days", 10);
        against = _m.addBy.days(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add10days, against, compare;
        add10days = _m.addBy.days(10);
        compare = now.clone().add("days", 10);
        against = add10days(now);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.hours", function() {
      it("accepts a number of hours to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("hours", 10);
        against = _m.addBy.hours(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("hours", 10);
        against = _m.addBy.hours(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add10hours, against, compare;
        add10hours = _m.addBy.hours(10);
        compare = now.clone().add("hours", 10);
        against = add10hours(now);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.minutes", function() {
      it("accepts a number of minutes to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("minutes", 10);
        against = _m.addBy.minutes(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("minutes", 10);
        against = _m.addBy.minutes(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add10mins, against, compare;
        add10mins = _m.addBy.minutes(10);
        compare = now.clone().add("minutes", 10);
        against = add10mins(now);
        return assert(meq(compare, against));
      });
    });
    describe("addBy.seconds", function() {
      it("accepts a number of seconds to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("seconds", 10);
        against = _m.addBy.seconds(10, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("seconds", 10);
        against = _m.addBy.seconds(10, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add10sec, against, compare;
        add10sec = _m.addBy.seconds(10);
        compare = now.clone().add("seconds", 10);
        against = add10sec(now);
        return assert(meq(compare, against));
      });
    });
    return describe("addBy.msec", function() {
      it("accepts a number of milliseconds to add and a moment instance", function() {
        var against, compare;
        compare = now.clone().add("milliseconds", 3500);
        against = _m.addBy.msec(3500, now);
        return assert(meq(compare, against));
      });
      it("does not mutate the original moment", function() {
        var against, compare;
        compare = now.clone().add("milliseconds", 3500);
        against = _m.addBy.msec(3500, now);
        assert(meq(compare, against));
        return assert(meq(against, now) === false);
      });
      return it("partially applies a single parameter", function() {
        var add3500msec, against, compare;
        add3500msec = _m.addBy.msec(3500);
        compare = now.clone().add("milliseconds", 3500);
        against = add3500msec(now);
        return assert(meq(compare, against));
      });
    });
  });

}).call(this);
